/* vim:fdm=marker ts=4 et ai
 * {{{
 *
 * Copyright (c) by Alexander Neumann <alexander@bumpern.de>
 * Copyright (c) 2007 by Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2007 by Christian Dietrich <stettberger@dokucode.de>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * For more information on the GPL, please go to:
 * http://www.gnu.org/copyleft/gpl.html
 }}} */

#include <string.h>
#include <avr/pgmspace.h>
#include <avr/eeprom.h>
#include <avr/interrupt.h>

#include "../config.h"
#include "../debug.h"
#include "../uip/uip.h"
#include "../uip/uip_arp.h"
#include "../eeprom.h"
#include "../bit-macros.h"
#include "../fs20/fs20.h"
#include "../portio.h"
#include "../lcd/hd44780.h"
#include "../named_pin/named_pin.h"
#include "../onewire/onewire.h"
#include "../rc5/rc5.h"
#include "../rfm12/rfm12.h"
#include "../dns/resolv.h"
#include "../clock/clock.h"
#include "../yport/yport.h"
#include "ecmd.h"

/* struct for storing commands */
struct ecmd_command_t {
    PGM_P name;
    int16_t (*func)(char*, char*, uint16_t);
};

/* Include the function header, generated by m4 */
#include "ecmd_defs.c"

int16_t ecmd_parse_command(char *cmd, char *output, uint16_t len)
/* {{{ */ {

#ifdef DEBUG_ECMD
    debug_printf("called ecmd_parse_command\n");
#endif

    if (strlen(cmd) <= 2) {
#ifdef DEBUG_ECMD
        debug_printf("cmd is too short\n");
#endif
        return 0;
    }

    int ret = -1;

    char *text = NULL;
    int16_t (*func)(char*, char*, uint16_t) = NULL;
    uint8_t pos = 0;

    while (1) {
        /* load pointer to text */
        text = (char *)pgm_read_word(&ecmd_cmds[pos].name);

#ifdef DEBUG_ECMD
        debug_printf("loaded text addres %p: \n", text);
#endif

        /* return if we reached the end of the array */
        if (text == NULL)
            break;

#ifdef DEBUG_ECMD
        debug_printf("text is: \"");
        printf_P(text);
        debug_printf("\"\n");
#endif

        /* else compare texts */
        if (memcmp_P(cmd, text, strlen_P(text)) == 0) {
#ifdef DEBUG_ECMD
            debug_printf("found match\n");
#endif
            cmd += strlen_P(text);
            func = (void *)pgm_read_word(&ecmd_cmds[pos].func);
            break;
        }

        pos++;
    }

#ifdef DEBUG_ECMD
    debug_printf("rest cmd: \"%s\"\n", cmd);
#endif

    if (func != NULL)
        ret = func(cmd, output, len);

    if (ret == -1 && output != NULL) {
        memcpy_P(output, PSTR("parse error"), 12);
        ret = 12;
    } else if (ret == 0) {
        output[0] = 'O';
        output[1] = 'K';
        ret = 2;
    }

    return ret;
} /* }}} */

int16_t parse_cmd_bootloader(char *cmd, char *output, uint16_t len)
/* {{{ */ {
    (void) cmd;
    (void) output;
    (void) len;

    cfg.request_bootloader = 1;
#   ifdef UIP_SUPPORT
    uip_close();
#   endif
    return 0;
} /* }}} */

#ifndef TEENSY_SUPPORT
int16_t parse_cmd_show_version(char *cmd, char *output, uint16_t len)
/* {{{ */ {
    (void) cmd;

    return snprintf_P(output, len,
            PSTR("version %s"), VERSION_STRING);
} /* }}} */

int16_t parse_cmd_reset(char *cmd, char *output, uint16_t len)
/* {{{ */ {
    (void) cmd;
    (void) output;
    (void) len;

    cfg.request_reset = 1;
    uip_close();
    return 0;
} /* }}} */

int16_t parse_cmd_wdreset(char *cmd, char *output, uint16_t len)
/* {{{ */ {
    cfg.request_wdreset = 1;
    uip_close();
    return 0;
} /* }}} */

int16_t parse_cmd_d(char *cmd, char *output, uint16_t len)
/* {{{ */ {
    (void) len;

    while (*cmd == ' ') cmd ++;

    uint16_t temp;
    if (sscanf_P (cmd, PSTR("%x"), &temp) != 1)
      return -1;

    unsigned char *ptr = (void *) temp;
    for (int i = 0; i < 16; i ++)
      sprintf_P (output + (i << 1), PSTR("%02x"), * (ptr ++));

    return 32;
} /* }}} */
#endif /* TEENSY_SUPPORT */
